#!/bin/sh
# Copyright (C) 2015  Etersoft
# Copyright (C) 2015  Vitaly Lipatov <lav@etersoft.ru>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#

# templates for multi part archive names
STZ="000000"
ST1="000001"
STN="??????"

DESCR="eterbackup version 0.3 (c) Etersoft 2015"

print_message()
{
	local DESC="$1"
	shift
	echo "$DESC in $(basename $0): $@"
}

# Print error message and stop the program
fatal()
{
	print_message Error "$@" >&2
	exit 1
}


list_dirs()
{
#echo "List dirs from $BACKUPDIR, with $EXCLUDEDIR exclude."
# Получаем список каталогов, которые мы хотим превратить в файлы
find $BACKUPDIR -depth -maxdepth $DEPTH -mindepth $DEPTH -type d -printf "%P\n" | \
while read reldir ; do

	bdir=$(basename "$reldir")

	# TODO: improve
	if [ "$bdir" = "$EXCLUDEDIR" ] ; then
		#echo "Skip excluded $bdir"
		continue
	fi

	echo "$reldir"
done
}

list_files()
{
	# Список файлов:
	find $BACKUPDIR -depth -maxdepth $DEPTH -mindepth 1 -type f -printf "%P\n"
}

# we need save all attrs before packing (for put files it in archive)
# FIXME: it needs write permission to the source tree
# FIXME: saved attrs for all file tree not every archive file
save_attrs()
{
	[ -n "$NOATTRIBUTE" ] && return
	local dir="."
	#[ -r ".metadata" ] || return
	# TODO: will we have error checking here?
	find $dir -depth -print -type b -or -type c -or -type p -or -type l -or -type s | pax -wd -f .eterpack.special.files.pax || return
	metastore -s || return
	# if didn't create, return
	#[ -r ".eterpack.special.files.pax" || return
}

remove_attrs()
{
	rm -f ".eterpack.special.files.pax" 2>/dev/null
	rm -f ".metadata" 2>/dev/null
}

# абсолютный путь к каталогу для восстановления
restore_attrs()
{
	#local dir="$1"
	#cd $dir || return
	# always uses local .metastore for all subdirs
	[ -s ".eterpack.special.files.pax" ] && pax -r -f .eterpack.special.files.pax
	[ -s ".metadata" ] && metastore -a

	remove_attrs
	#cd - >/dev/null
	return 0
}

update_dump()
{
# Получаем список каталогов, которые мы хотим превратить в файлы
find $BACKUPDIR -depth -maxdepth $DEPTH -mindepth $DEPTH -type d -printf "%P\n" | \
while read reldir ; do

	bdir="$(basename "$reldir")"

	# TODO: improve
	if [ "$bdir" = "$EXCLUDEDIR" ] ; then
		echo "Skip excluded $bdir"
		continue
	fi

	# TODO: удалённые каталоги будут незамечены и останутся.
	# Создавать новый слой, копируя со старого, и оставляя тот старыми датами?

	# FIXME: copy dir permissions
	mkdir -p "$DUMPDIR/$reldir"

	# workaround for correct internal path
	cd "$BACKUPDIR/$reldir/.." || exit

	echo
	echo "Packing $reldir/$bdir ..."
	# TODO: use -to for rename internal path
	zpaq add "$DUMPDIR/$reldir/$bdir.$STN.zpaq" "$bdir" $CHECKSUM || { cd - ; exit 1 ; }
	cd - >/dev/null

	if [ -n "$EXECUTEAFTER" ] ; then
		$EXECUTEAFTER "$DUMPDIR/$reldir/$bdir.$STN.zpaq" || fatal "Executed command $EXECUTEAFTER failed"
	fi
done || return

# Получаем список файлов в корне
# TODO: Здесь бы надо просто выключить рекурсию, но неизвестно как
# Также неизвестно, как раскрыть
# FIXME: broken with paths with spaces
# TODO: не поддерживается удаление файлов
local FILES=$(list_files)

	echo
	echo "Save attrs and special files..."
	cd "$BACKUPDIR" || exit
	if save_attrs ; then
		# TODO: overhead
		[ -s ".eterpack.special.files.pax" ] && FILES="$FILES .eterpack.special.files.pax"
		[ -s ".metadata" ] && FILES="$FILES .metadata"
	fi
	cd - >/dev/null

if [ -n "$FILES" ] ; then

	bdir="$(basename "$BACKUPDIR")"

	# FIXME: copy dir permissions
	mkdir -p "$DUMPDIR"

	# workaround for correct internal path
	cd "$BACKUPDIR" || exit

	echo
	echo "Packing files ..."
	# TODO: use -to for rename internal path
	zpaq add "$DUMPDIR/$bdir.$STN.zpaq" $FILES $CHECKSUM || { cd - ; return 1 ; }
	remove_attrs
	cd - >/dev/null

	if [ -n "$EXECUTEAFTER" ] ; then
		$EXECUTEAFTER "$DUMPDIR/$bdir.$STN.zpaq" || fatal "Executed command $EXECUTEAFTER failed"
	fi
fi

}

repack_dump()
{
fatal "Do not realized jet! zpaq purge does not exists anymore!"
# Получаем список каталогов, которые мы хотим превратить в файлы
find "$BACKUPDIR" -depth -maxdepth $DEPTH -mindepth $DEPTH -type d -printf "%P\n" | \
while read reldir ; do

	bdir="$(basename "$reldir")"

	# TODO: improve
	if [ "$bdir" = "$EXCLUDEDIR" ] ; then
		echo
		echo "Skip excluded $bdir"
		continue
	fi

	# TODO: удалённые каталоги будут незамечены и останутся.
	# Создавать новый слой, копируя со старого, и оставляя тот старыми датами?

	# FIXME: copy dir permissions
	mkdir -p "$DUMPDIR/$reldir"

	# TODO: тут нужно сделать другой обход каталогов (готовых)
	# TODO: выделить в отдельную функцию
	# TODO: check it
	zpaq purge "$DUMPDIR/$reldir/$bdir.$STN.zpaq" -to "$DUMPDIR/$reldir/../$bdir.$STZ.zpaq" || exit
	rm -f "$DUMPDIR/$reldir/$bdir.$STN.zpaq"
	mv "$DUMPDIR/$reldir/../$bdir.$STZ.zpaq" "$DUMPDIR/$reldir/$bdir.$STZ.zpaq"
done
}

extract_dump()
{
mkdir -p "$DESTDIR" || fatal "Can't create output directory $DESTDIR"
# Note: it is important to use ???.zpaq during extract (000.zpaq has no files, 001.zpaq will unpack only this archive).
find "$DUMPDIR" -type f -name "*.$STZ.zpaq" -printf "%P\n" | sed -e "s|\.$STZ.zpaq$|.$STN.zpaq|g" | \
while read relfile ; do
	reldir="$(dirname "$relfile")"
	# FIXME: copy dir permissions
	# TODO: хранить структуру каталогов отдельно, сразу и проверка?

	# workaround for root archive
	if [ "$reldir" = "." ] ; then
		tdir="$DESTDIR"
	else
		tdir="$(realpath -m "$DESTDIR/$reldir/..")"
	fi

	echo
	echo "Extract files from $relfile to $tdir ..."
	zpaq extract "$DUMPDIR/$relfile" -to "$tdir" || exit
done

	cd "$DESTDIR" || return
	echo
	echo "Restore attrs ..."
	restore_attrs "$tdir"
	cd - >/dev/null
}

compare_dump()
{
	[ -d "$DESTDIR" ] || fatal "Can't open directory $DESTDIR"
	# Note: it is important to use ???.zpaq during extract (000.zpaq has no files, 001.zpaq will unpack only this archive).
	find "$DUMPDIR" -type f -name "*.$STZ.zpaq" -printf "%P\n" | sed -e "s|\.$STZ.zpaq$|.$STN.zpaq|g" | \
	while read relfile ; do
		reldir="$(dirname "$relfile")"

		echo
		echo "Compare files from $relfile with $DESTDIR/$reldir ..."
		zpaq list "$DUMPDIR/$relfile" "$reldir" -to "$DESTDIR/$reldir" -not = $CHECKSUM || exit
	done || return
}

test_dump()
{
	# Note: it is important to use ???.zpaq during extract (000.zpaq has no files, 001.zpaq will unpack only this archive).
	find "$DUMPDIR" -type f -name "*.$STZ.zpaq" -printf "%P\n" | sed -e "s|\.$STZ.zpaq$|.$STN.zpaq|g" | \
	while read relfile ; do
		reldir="$(dirname "$relfile")"

		echo
		echo "Checking $relfile ..."
		zpaq extract "$DUMPDIR/$relfile" -test || exit
	done || return

	# TODO: add checking by dirs.lists (correct structure)
}

COMMAND=$1
shift

DEPTH=1
if [ "$1" = "-depth" ] || [ "$1" = "--depth" ] ; then
	shift
	DEPTH=$1
	shift
fi

EXCLUDEDIR=
if [ "$1" = "--exclude" ] ; then
	shift
	EXCLUDEDIR="$1"
	shift
fi

EXECUTEAFTER=
if [ "$1" = "--execute" ] ; then
	shift
	EXECUTEAFTER="$1"
	shift
fi

CHECKSUM=
if [ "$1" = "--checksum" ] ; then
	shift
	CHECKSUM="-force"
fi

NOATTRIBUTE=
if [ "$1" = "--noattribute" ] ; then
	shift
	NOATTRIBUTE=1
fi

case $COMMAND in
	update)
		# from
		BACKUPDIR="$(realpath -e "$1")" || exit

		# to
		DUMPDIR="$(realpath -m "$2")"

		update_dump || exit
		# TODO: это второй прогон. Надо встроить внутрь. Но там будет дописывание в файл
		list_dirs >$DUMPDIR/dirs.list
		list_files >$DUMPDIR/files.list
	;;
	repack)
		# from
		BACKUPDIR="$(realpath -e "$1")" || exit

		# to
		DUMPDIR="$(realpath -m "$2")"
		repack_dump
	;;
	compare)
		DUMPDIR="$(realpath -e "$1")"

		DESTDIR="$(realpath -e "$2")"
		compare_dump
	;;
	inlist)
		# from
		BACKUPDIR="$(realpath -e "$1")" || exit
		echo "Dirs:"
		list_dirs
		echo
		echo "Files:"
		list_files
	;;
	extract)
		DUMPDIR="$(realpath -e "$1")" || exit
		# source dirname for target by default
		DESTDIR="$(basename $DUMPDIR)"
		[ -n "$2" ] && DESTDIR="$(realpath -m "$2")"
		extract_dump
	;;
	test|check)
		DUMPDIR="$(realpath -e "$1")" || exit
		test_dump
	;;
	-h|--help)
		echo $DESCR
		echo "Run with $0 command [options] args"

		echo
		echo "Update backup:"
		echo "	$ eterbackup update /path/from /path/to"

		#echo
		#echo "Repack backup (refresh zpaq files for minimize):"
		#echo "	$ eterbackup repack /path/from /path/to"

		echo
		echo "Extract backup:"
		echo "	$ eterbackup extract /path/backup /path/to"

		echo
		echo "Compare backup:"
		echo "	$ eterbackup compare /path/backup /path/to"

		echo
		echo "Test backup:"
		echo "	$ eterbackup test /path/backup"

		echo
		echo "Options:"
		echo "	--depth N          - set depth for subdirs (update only)"
		echo "	--exclude name     - exclude dir 'name' from packing"
		echo "	--execute command  - execute 'command' after every archive"
		echo "	--checksum         - force checking file contains, not date only"
		echo "	--noattribute      - do not extra save owner/group, permissions and special files"
	;;
	*)
		echo "$DESCR" >&2
		echo "Run with -h or --help for help" >&2
		exit 1
	;;
esac

