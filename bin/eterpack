#!/bin/sh
# Copyright (C) 2015  Etersoft
# Copyright (C) 2015  Vitaly Lipatov <lav@etersoft.ru>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#

# templates for multi part archive names
STZ="000000"
ST1="000001"
STN="??????"

DESCR="eterbackup version 0.3 (c) Etersoft 2015"

print_message()
{
	local DESC="$1"
	shift
	echo "$DESC in $(basename $0): $@"
}

# Print error message and stop the program
fatal()
{
	print_message Error "$@" >&2
	exit 1
}


list_dirs()
{
#echo "List dirs from $BACKUPDIR, with $EXCLUDEDIR exclude."
# Получаем список каталогов, которые мы хотим превратить в файлы
find $BACKUPDIR -depth -maxdepth $DEPTH -mindepth $DEPTH -type d -printf "%P\n" | \
while read reldir ; do

	bdir=$(basename "$reldir")

	# TODO: improve
	if [ "$bdir" = "$EXCLUDEDIR" ] ; then
		#echo "Skip excluded $bdir"
		continue
	fi

	echo "$reldir"
done
}

list_files()
{
	# Список файлов:
	find $BACKUPDIR -depth -maxdepth $DEPTH -mindepth 1 -type f -printf "%P\n"
}

update_dump()
{
# Получаем список каталогов, которые мы хотим превратить в файлы
find $BACKUPDIR -depth -maxdepth $DEPTH -mindepth $DEPTH -type d -printf "%P\n" | \
while read reldir ; do

	bdir="$(basename "$reldir")"

	# TODO: improve
	if [ "$bdir" = "$EXCLUDEDIR" ] ; then
		echo "Skip excluded $bdir"
		continue
	fi

	# TODO: удалённые каталоги будут незамечены и останутся.
	# Создавать новый слой, копируя со старого, и оставляя тот старыми датами?

	# FIXME: copy dir permissions
	mkdir -p "$DUMPDIR/$reldir"

	# workaround for correct internal path
	cd "$BACKUPDIR/$reldir/.." || exit

	echo
	echo "Packing $reldir/$bdir..."
	zpaq a "$DUMPDIR/$reldir/$bdir.$STN.zpaq" "$bdir"
	cd - >/dev/null

	if [ -n "$EXECUTEAFTER" ] ; then
		$EXECUTEAFTER "$DUMPDIR/$reldir/$bdir.$STN.zpaq" || fatal "Executed command $EXECUTEAFTER failed"
	fi
done

# Получаем список файлов в корне
# TODO: Здесь бы надо просто выключить рекурсию, но неизвестно как
# Также неизвестно, как раскрыть
# FIXME: broken with paths with spaces
local FILES=$(list_files)
if [ -n "$FILES" ] ; then

	bdir="$(basename "$BACKUPDIR")"

	# FIXME: copy dir permissions
	mkdir -p "$DUMPDIR"

	# workaround for correct internal path
	cd "$BACKUPDIR" || exit

	# packing
	zpaq a "$DUMPDIR/$bdir.$STN.zpaq" $FILES
	cd - >/dev/null

	if [ -n "$EXECUTEAFTER" ] ; then
		$EXECUTEAFTER "$DUMPDIR/$bdir.$STN.zpaq" || fatal "Executed command $EXECUTEAFTER failed"
	fi
fi

}

repack_dump()
{
fatal "Do not realized jet!"
# Получаем список каталогов, которые мы хотим превратить в файлы
find "$BACKUPDIR" -depth -maxdepth $DEPTH -mindepth $DEPTH -type d -printf "%P\n" | \
while read reldir ; do

	bdir="$(basename "$reldir")"

	# TODO: improve
	if [ "$bdir" = "$EXCLUDEDIR" ] ; then
		echo
		echo "Skip excluded $bdir"
		continue
	fi

	# TODO: удалённые каталоги будут незамечены и останутся.
	# Создавать новый слой, копируя со старого, и оставляя тот старыми датами?

	# FIXME: copy dir permissions
	mkdir -p "$DUMPDIR/$reldir"

	# TODO: тут нужно сделать другой обход каталогов (готовых)
	# TODO: выделить в отдельную функцию
	# TODO: check it
	zpaq purge "$DUMPDIR/$reldir/$bdir.$STN.zpaq" -to "$DUMPDIR/$reldir/../$bdir.$STZ.zpaq" || exit
	rm -f "$DUMPDIR/$reldir/$bdir.$STN.zpaq"
	mv "$DUMPDIR/$reldir/../$bdir.$STZ.zpaq" "$DUMPDIR/$reldir/$bdir.$STZ.zpaq"
done
}

extract_dump()
{
mkdir -p "$DESTDIR" || fatal "Can't create output directory $DESTDIR"
# Note: it is important to use ???.zpaq during extract (000.zpaq has no files, 001.zpaq will unpack only this archive).
find "$DUMPDIR" -type f -name "*.$STZ.zpaq" -printf "%P\n" | sed -e "s|\.$STZ.zpaq$|.$STN.zpaq|g" | \
while read relfile ; do
	reldir="$(dirname "$relfile")"
	# FIXME: copy dir permissions
	# TODO: хранить структуру каталогов отдельно, сразу и проверка?

	# workaround for root archive
	if [ "$reldir" = "." ] ; then
		tdir="$DESTDIR"
	else
		tdir="$(realpath -m "$DESTDIR/$reldir/..")"
	fi

	echo
	echo "Extract files from $relfile to $tdir ..."
	zpaq extract "$DUMPDIR/$relfile" -to "$tdir" || return
done
}

compare_dump()
{
	[ -d "$DESTDIR" ] || fatal "Can't open directory $DESTDIR"
	# Note: it is important to use ???.zpaq during extract (000.zpaq has no files, 001.zpaq will unpack only this archive).
	find "$DUMPDIR" -type f -name "*.$STZ.zpaq" -printf "%P\n" | sed -e "s|\.$STZ.zpaq$|.$STN.zpaq|g" | \
	while read relfile ; do
		reldir="$(dirname "$relfile")"

		echo
		echo "Compare files from $relfile with $DESTDIR/$reldir ..."
		zpaq list "$DUMPDIR/$relfile" "$reldir" -to "$DESTDIR/$reldir" -not = || return
	done
}

COMMAND=$1
shift

DEPTH=1
if [ "$1" = "-depth" ] || [ "$1" = "--depth" ] ; then
	shift
	DEPTH=$1
	shift
fi

EXCLUDEDIR=
if [ "$1" = "--exclude" ] ; then
	shift
	EXCLUDEDIR="$1"
	shift
fi

EXECUTEAFTER=
if [ "$1" = "--execute" ] ; then
	shift
	EXECUTEAFTER="$1"
	shift
fi

case $COMMAND in
	update)
		# from
		BACKUPDIR="$(realpath -e "$1")" || exit

		# to
		DUMPDIR="$(realpath -m "$2")"
		update_dump
		# TODO: это второй прогон. Надо встроить внутрь. Но там будет дописывание в файл
		list_dirs >$DUMPDIR/dirs.list
		list_files >$DUMPDIR/files.list
	;;
	repack)
		# from
		BACKUPDIR="$(realpath -e "$1")" || exit

		# to
		DUMPDIR="$(realpath -m "$2")"
		repack_dump
	;;
	compare)
		DUMPDIR="$(realpath -e "$1")"

		DESTDIR="$(realpath -e "$1")"
		compare_dump
	;;
	list)
		# from
		BACKUPDIR="$(realpath -e "$1")" || exit
		echo "Dirs:"
		list_dirs
		echo
		echo "Files:"
		list_files
	;;
	extract)
		DUMPDIR="$(realpath -e "$1")" || exit
		# source dirname for target by default
		DESTDIR="$(basename $DUMPDIR)"
		[ -n "$2" ] && DESTDIR="$(realpath -m "$2")"
		extract_dump
	;;
	-h|--help)
		echo $DESCR
		echo "Run with $0 command [options] args"

		echo
		echo "Update backup:"
		echo "	$ eterbackup update /path/from /path/to"

		echo
		echo "Repack backup (refresh zpaq files for minimize):"
		echo "	$ eterbackup repack /path/from /path/to"

		echo
		echo "Extract backup:"
		echo "	$ eterbackup extract /path/backup /path/to"

		echo
		echo "Options:"
		echo "	--depth N          - set depth for subdirs (update only)"
		echo "	--exclude name     - exclude dir 'name' from packing"
		echo "	--execute command  - execute 'command' after every archive"
	;;
	*)
		echo "$DESCR" >&2
		echo "Run with -h or --help for help" >&2
		exit 1
	;;
esac

